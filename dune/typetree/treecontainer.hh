// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:

#ifndef DUNE_TYPETREE_TREECONTAINER_HH
#define DUNE_TYPETREE_TREECONTAINER_HH

#include <type_traits>
#include <utility>
#include <functional>

#include <dune/common/indices.hh>
#include <dune/typetree/childextraction.hh>
#include <dune/typetree/treepath.hh>
#include <dune/typetree/transformtree.hh>
#include <dune/typetree/typetrees.hh>

namespace Dune {
namespace TypeTree {
namespace Detail {

/**
  * \brief A simple lambda for creating default constructible values from a node
  *
  * This simply returns LeafToValue<Node>{} for a given Node. It's needed
  * because using a lambda expression in a using declaration is not allowed
  * because it's an unevaluated context.
  */
template<template<class Node> class LeafToValue>
struct LeafToDefaultConstructibleValue
{
  template<class Node>
  auto operator()(const Node& node) const
  {
    return LeafToValue<Node>{};
  }
};

} // namespace Detail


//! Wrap a tree and transform it into a vector backend
template<class Node>
class ContainerNodeMixin
    : public Node
{
public:
  template<class N,
    std::enable_if_t<Dune::IsInteroperable<N,Node>::value, int> = 0>
  explicit ContainerNodeMixin(N&& node)
    : Node{std::forward<N>(node)}
  {}

  //! Access the tree childs using a tree-path (const access)
  template<class... T>
  const auto& operator[](const TypeTree::HybridTreePath<T...>& path) const
  {
    return TypeTree::child(static_cast<Node const&>(*this), path);
  }

  //! Access the tree childs using a tree-path (mutable access)
  template<class... T>
  auto& operator[](const TypeTree::HybridTreePath<T...>& path)
  {
    return TypeTree::child(static_cast<Node&>(*this), path);
  }
};

// deduction guide
template<class Node>
ContainerNodeMixin(Node&& node)
  -> ContainerNodeMixin<std::decay_t<Node>>;


/** \addtogroup TypeTree
 *  \{
 */

/**
 * \brief Create container having the same structure as the given tree
 *
 * This class allows to create a nested hybrid container having the same structure
 * as a given type tree. Power nodes are represented as std::array's while composite
 * nodes are represented as Dune::TupleVector's. The stored values for the leaf nodes
 * are creating using a given predicate. For convenience the created container is
 * not returned directly. Instead, the returned object stores the container and
 * provides operator[] access using a HybridTreePath.
 *
 * \param tree The tree which should be mapper to a container
 * \param leafToValue A mapping `Node -> Value` used to generate the stored values
 *                    for the leaves
 *
 * \returns A container matching the tree structure
 */
template <class Tree, class LeafToValue>
auto makeTreeContainer(Tree const& tree, LeafToValue leafToValue)
{
  return transformTree(tree, [leafToValue](auto&& node) {
    using Node = std::decay_t<decltype(node)>;
    if constexpr(Node::isLeaf)
      return leafToValue(std::forward<decltype(node)>(node));
    else
      return ContainerNodeMixin<Node>{std::forward<decltype(node)>(node)};
  });
}

/**
 * \brief Create container havin the same structure as the given tree
 *
 * This class allows to create a nested hybrid container having the same structure
 * as a given type tree. Power nodes are represented as std::array's while composite
 * nodes are represented as Dune::TupleVector's. The stored values for the leaf nodes
 * are of the given type Value. For convenience the created container is
 * not returned directly. Instead, the returned object stores the container and
 * provides operator[] access using a HybridTreePath.
 *
 * \tparam Value Type of the values to be stored for the leafs. Should be default constructible.
 * \param leafToValue A predicate used to generate the stored values for the leaves
 *
 * \returns A container matching the tree structure
 */
template<class Value, class Tree,
  std::enable_if_t<std::is_default_constructible_v<Value>, int> = 0>
auto makeTreeContainer(const Tree& tree)
{
  return makeTreeContainer(tree, [](const auto&) {return Value{};});
}

/**
 * \brief Alias to container type generated by makeTreeContainer for given tree type and uniform value type
 */
template<class Value, class Tree>
using UniformTreeContainer = decltype(makeTreeContainer<Value>(std::declval<const Tree&>()));

/**
 * \brief Alias to container type generated by makeTreeContainer for give tree type and when using LeafToValue to create values
 */
template<template<class Node> class LeafToValue, class Tree>
using TreeContainer = decltype(makeTreeContainer(std::declval<const Tree&>(), std::declval<Detail::LeafToDefaultConstructibleValue<LeafToValue>>()));

//! \} group TypeTree

} // namespace TypeTree
} // namespace Dune

#endif // DUNE_TYPETREE_TREECONTAINER_HH
